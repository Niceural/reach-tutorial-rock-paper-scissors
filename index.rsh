"reach 0.1"; // usual Reach version header

// define enumerations for the hands that may be played, as well as the outcomes of the game
const [isHand, ROCK, PAPER, SCISSORS] = makeEnum(3);
const [isOutcome, B_WINS, DRAW, A_WINS] = makeEnum(3);

// define the function that computes the winner of the game
const winner = (handAlice, handBob) => (handAlice + (4 - handBob)) % 3;

// makes an assertion that when Alice plays Rock and Bob plays Paper, then Bob wins as expected
assert(winner(ROCK, PAPER) == B_WINS);
assert(winner(PAPER, ROCK) == A_WINS);
assert(winner(ROCK, ROCK) == DRAW);

// state that no matter what values are provided for handAlice and handBob, winner will always provide a valid outcome
forall(UInt, (handAlice) =>
  forall(UInt, (handBob) => assert(isOutcome(winner(handAlice, handBob))))
);

// specify that whenever the same value is provided for both hands, no matter what it is, winner always returns DRAW
forall(UInt, (hand) => assert(winner(hand, hand) == DRAW));

const Player = {
  ...hasRandom, // from reach standard library, to generate a random number to protect Alice's hand
  getHand: Fun([], UInt),
  seeOutcome: Fun([UInt], Null),
  informTimeout: Fun([], Null), // receives no arguments and returns no information. We'll call this function when a timeout occurs
};

export const main = Reach.App(() => {
  const Alice = Participant("Alice", {
    ...Player, // define Alice's interface as the Player interface
    wager: UInt,
    deadline: UInt, // adds the deadline field to Alice's participant interact interface. It is defined as some number of time delta units, which are an abstraction of the underlying notion of network time in the consensus network. In many networks, like Ethereum, this number is a number of blocks
  });
  const Bob = Participant("Bob", {
    ...Player,
    acceptWager: Fun([UInt], Null),
  });
  init();

  const informTimeout = () => {
    each([Alice, Bob], () => {
      interact.informTimeout();
    });
  };

  Alice.only(() => {
    const wager = declassify(interact.wager); // declassify the wager for transmission
    const _handAlice = interact.getHand(); // has Alice compute her hand, but not declassify it
    const [_commitAlice, _saltAlice] = makeCommitment(interact, _handAlice); // has her compute a commitment to the hand. It comes with a secret "salt" value that must be revealed later. This "salt" was generated by the random function inside of hasRandom and it's why we pass interact to this function
    const commitAlice = declassify(_commitAlice); // has Alice declassify the commitment
    const deadline = declassify(interact.deadline);
  });
  Alice.publish(wager, commitAlice, deadline) // Alice shares the wager amount with Bob
    .pay(wager); // has her transfer the amount as part of her publication. The Reach compiler would throw an exception if wager did not appear on line 23, but did appear on line 24. Change the program and try it. This is because the consensus network needs to be able to verify that the amount of network tokens included in Alice's publication match some computation available to consensus network
  commit();

  unknowable(Bob, Alice(_handAlice, _saltAlice));
  Bob.only(() => {
    interact.acceptWager(wager); // has Bob accept the wager. If he doesn't like the terms, his frontend can just not respond to this method and the DApp will stall
    const handBob = declassify(interact.getHand());
  });
  Bob.publish(handBob)
    .pay(wager)
    .timeout(relativeTime(deadline), () => closeTo(Alice, informTimeout));
  commit();

  Alice.only(() => {
    const saltAlice = declassify(_saltAlice);
    const handAlice = declassify(_handAlice);
  });
  Alice.publish(saltAlice, handAlice).timeout(relativeTime(deadline), () =>
    closeTo(Bob, informTimeout)
  );
  checkCommitment(commitAlice, saltAlice, handAlice); // checks that the published values match the original values. This will always be the case with honest participants, but dishonest participants may violate this assumption

  const outcome = (handAlice + (4 - handBob)) % 3;
  const [forAlice, forBob] =
    outcome == A_WINS ? [2, 0] : outcome == B_WINS ? [0, 2] : /* tie */ [1, 1];
  transfer(forAlice * wager).to(Alice);
  transfer(forBob * wager).to(Bob);
  commit();

  each([Alice, Bob], () => {
    interact.seeOutcome(outcome);
  });
});
